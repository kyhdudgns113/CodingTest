#
# L : 광고판에 나타난 문자열의 길이 (L <= 1,000,000)
# inputString : 광고판에 나타난 문자열
#
# 상황
#   광고판에 띄울 문구를 입력한다. (길이 <= L)
#   길이가 L 보다 부족하면, 광고문구를 이어서 출력하여 길이 L 을 채운다.
#     L = 6 이고 광고문구가 1234 이면
#       123412, 234123, 341234, 412341 이 나올 수 있다.
#
# 구하는것
#   광고판에 나타나는 문자열의 길이와 한 순간에 나타난 문자열이 주어질때
#   가능한 광고문구중 가장 짧은것
#
# 풀이
#   구하려는 가장 짧은 광고문구를 다음과 같이 2개의 파트로 나눌 수 있다.
#     광고문구 = AB
#     A : 마지막에 반복되는 부분
#     B : 마지막에는 반복되지 않는 부분
#   A 와 B 의 정의에 의해 화면에는 다음과 같이 뜰 수 있다.
#     inputString = AB, ABA, ABABA, ABABABA.....
#   inputString 에서 최대 공통 접미사를 빼면 구하는 AB 가 나온다.
#     AB 이면 최대 공통 접미사는 NULL 이다.
#       - 애당초 AB 의 정의는 구하려는 가장 짧은 광고문구이다.
#       - AB 에서 NULL 을 빼면 AB 그대로 나온다.
#     ABA 이면 최대 공동 접미사는 A 이다.
#       - 이를 빼면 AB 가 나온다.
#     ABABA 이면 최대 공통 접미사는 ABA 이다.
#       - 이를 빼면 역시 AB 가 나온다.
#   즉 최대 접미사의 길이를 구하면 광고문구의 최소길이를 알 수 있다.
#
# 연산량
#   KMP 알고리즘에서 최대 접미사의 길이를 구하는 연산은 O(L) 이다.
#   = 백만만  
#

import sys

input = sys.stdin.readline

L = int(input())
inputString = list(input().strip())

# F[i] : i 번째 글자가 마지막일때 최대 공통 접미사의 길이이
F = [0 for i in range(L)]

i = 0
j = 1

while j < L:
  if inputString[j] == inputString[i]:
    F[j] = i + 1
    j += 1
    i += 1
  else:
    if i > 0:
      i = F[i - 1]
    else:
      j += 1

print(L - F[-1])
