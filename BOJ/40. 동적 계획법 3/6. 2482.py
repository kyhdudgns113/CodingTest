#
# pypy 로 돌려야 한다.
#
# N : 전체 색의 갯수
# K : 고르는 색의 갯수
#
# 상황
#   색은 원탁에 순환구조로 배치되어 있다.
#     시작색과 끝색은 맞닿아있다.
#   색은 한 칸 건너서만 고를 수 있다.
#
# 구하는것
#   색을 고르는 경우의 수를 1,000,000,003 으로 나눈 값
#
# 풀이
#   unUse0Arr[k][n]
#     0 번째 색을 "고르지 않고"
#     k 번째 색을 골랐을때 
#     n 을 고르는 경우의 수
#   use0Arr[k][n]
#     0 번째 색을 "고른 상태에서"
#     k 번째 색을 골랐을때
#     n 을 고르는 경우의 수
#
#   k 번째 색으로 n 을 골랐으면 k + 1 번째 색으로
#     n + 2 번째 색을 고를 수 있다.
#     n + 3 번째 색도 고를 수 있다.
#     ...
#     N - 1 번째 색도 고를 수있다.
#
#   이는
#     unUse0Arr[k][n] 값이 존재한다면 이 값만큼
#       unUse0Arr[k + 1][n + 2]
#       unUse0Arr[k + 1][n + 3]
#           ...
#       에 더해줄 수 있다는 뜻이 된다.
#
#   이를 점화식으로 세워서 풀면 아래 코드와 같다.
#
#   다만, 아래에서 후술할 연산량이 간당간당하여 연산 최적화를 해줘야 한다.
#     => 불필요한 연산은 제거한다.
#
# 연산량
#   A. 모든 k 번째 선택에 대하여 : O(K)
#   B. 모든 색깔들이 선택되는 경우에서 : O(N)
#   C. 모든 다음 색깔들을 선택하는 경우를 계산한다 : O(N)
#       = O(K * N^2)
#       = 10 억
#   이대로는 1초(약 1억) 을 한참 초과하여 시간초과가 나온다.
#
#   1. K 가 N 의 절반보다 크면 인접하지 않은 색을 K 개만큼 못 고른다
#     => 바로 0 출력
#   2. 남은 선택 개수가 remain 개 만큼 있으면 N - 2*remain 번째 이후의 색은 현재재 순번으로 고를 수 없다.
#     - 현재 순번을 k 라고 하면 남은 갯수 remain 은 K - k 이다.
#     - k 번째 수를 N - 2*remain 이후로 고르면 결국은 K 개를 채우지 못하고 한 바퀴를 돌게 된다.
#   3. 다음 순번(k + 1)의 수는 현재순번 + 2부터 시작한다.
#   4. 다음 순번의 수는 N - 2*remain + 2 이상이 될 수 없다,
#     2번과 같은 논리이다.
#
#   1~4 를 이용해 연산을 최적화하면
#     A 연산 : K 의 최대값은 1번에 의해 500이 된다.
#     B 연산 : N = 1,000, K = 500 을 입력받았어도 평균적으로 최대 500번만 연산된다.
#       -> k 값에 따라서 1000 번 연산하다가 0번까지 떨어진다.
#     C 연산 : 마찬가지로 500번 이하까지 연산된다.
#       -> 현재보다 2 이상부터 연산되므로 그것보단 더 적어진다.
#   = 약 1억 2천500만
#
#   이는 python 으로는 시간초과가 나지만 pypy 로는 잘 돌아간다.
#

N = int(input())
K = int(input())

G = (10 ** 9) + 3

if K > N // 2:
  print(0)
  exit()

# unUse0Arr[k][n]
#   시작지점을 색칠하지 않은 상태에서
#   k 번째 색을 n번째에 칠하는 경우의 수
unUse0Arr = [[0 for i in range(N)] for j in range(K + 1)]
use0Arr = [[0 for i in range(N)] for j in range(K + 1)]

use0Arr[1][0] = 1

for i in range(1, N):
  unUse0Arr[1][i] = 1

for k in range(1, K):
  remain = K - k
  for now in range(N - 2*remain):
    if unUse0Arr[k][now] == 0 and use0Arr[k][now] == 0:
      continue
    for next in range(now + 2, N - 2*remain + 2):
      unUse0Arr[k + 1][next] += unUse0Arr[k][now]
      unUse0Arr[k + 1][next] %= G
      
      # N - 1 번째 숫자를 고르려면 0번째 숫자를 안 고른 상태여야 한다.
      if next != N - 1:
        use0Arr[k + 1][next] += use0Arr[k][now]
        use0Arr[k + 1][next] %= G
        

print((sum(use0Arr[K]) + sum(unUse0Arr[K])) % G)